#version 460

#extension GL_EXT_scalar_block_layout: require
#extension GL_EXT_nonuniform_qualifier: require

layout(constant_id = 0) const uint SPHERE_COUNT = 1;

layout(constant_id = 1) const uint TRIANGLE_VERTEX_COUNT = 1;
layout(constant_id = 2) const uint TRIANGLE_COUNT = 1;
layout(constant_id = 3) const uint TRIANGLE_MATERIAL_COUNT = 1;

#include "material.glsl"
#include "geometry.glsl"
#include "random.glsl"

#define RAY_BOUNCE_MAX_COUNT 10
#define PI 3.1415926535
#define ONE_OVER_PI (1 / 3.1415926535)

struct ray_t {
    vec3 origin;
    vec3 direction;
};

struct hit_record_t {
    vec3 point;
    // normal always points against ray direction
    vec3 normal;
    material_t material;
    float t;
    vec2 albedo_uv;
    bool front_face;
};

vec3 ray_at(const in ray_t ray,
            const in float t);

hit_record_t empty_hit_record();

void hit_record_set_front_face(inout hit_record_t record, 
                               const in ray_t ray,
                               const in vec3 outward_normal);

bool hit_sphere(const in sphere_t sphere, 
                const in ray_t ray, 
                const in float t_min,
                const in float t_max,
                out hit_record_t record);

bool hit_triangle(const in triangle_t triangle,
                  const in ray_t ray,
                  const in float t_min,
                  const in float t_max,
                  out hit_record_t record);

vec3 gradient_background(const in vec3 top_color,
                         const in vec3 bottom_color,
                         const in ray_t ray);

bool near_zero(const in vec3 vector);

int max_component_index(const in vec3 vector);

float reflectance(const in float cosine, 
                  const in float refraction_ratio);

vec3 scatter(inout ray_t ray,
             const in hit_record_t hit_record);

vec3 brute_force_ray_tracing(in ray_t ray);

vec3 ddd_dda_ray_tracing(in ray_t ray);

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, set = 0, binding = 0) uniform image2D img_output;

layout(std430, set = 0, binding = 1) uniform camera {
    vec3 pixel_delta_u;
    vec3 pixel_delta_v;
    vec3 upper_left_pixel;
    vec3 camera_position;
    float accumulated_scalar;
};

layout(std430, set = 0, binding = 2) uniform sphere_geometries {
// + 1 to prevent empty buffer error when no sphere presents
    sphere_t spheres[SPHERE_COUNT + 1];
};

layout(std430, set = 0, binding = 3) uniform triangle_geometries_vertex {
    triangel_vertex_t triangle_vertices[TRIANGLE_VERTEX_COUNT + 1];
};

layout(std430, set = 0, binding = 4) uniform triangle_geometries_face {
    triangle_t triangles[TRIANGLE_COUNT + 1];
};

layout(std430, set = 0, binding = 5) uniform triangle_geometries_materials {
    material_t triangle_materials[TRIANGLE_MATERIAL_COUNT + 1];
};

layout(set = 1, binding = 0) uniform sampler2D textures[];

void main() {
    const ivec2 tex_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec3 pixel = upper_left_pixel + 
                 tex_coord.x * pixel_delta_u + 
                 tex_coord.y * pixel_delta_v;

    const float sample_offset_x = -0.5 + rand_01(vec2(gl_GlobalInvocationID.x, accumulated_scalar));
    const float sample_offset_y = -0.5 + rand_01(vec2(gl_GlobalInvocationID.y, accumulated_scalar));
    const vec3 pixel_sample_offset = sample_offset_x * pixel_delta_u + 
                                     sample_offset_y * pixel_delta_v;
    const vec3 pixel_sample = pixel + pixel_sample_offset;
    ray_t ray = ray_t(camera_position, normalize(pixel_sample - camera_position));
    vec3 destination_color = brute_force_ray_tracing(ray);

    const vec3 source_color = imageLoad(img_output, tex_coord).xyz;
    imageStore(img_output, 
               tex_coord, 
               vec4(source_color + destination_color, 1.0));
}

vec3 ray_at(const in ray_t ray,
            const in float t) {
    return ray.origin + t * ray.direction;
}

hit_record_t empty_hit_record() {
    return hit_record_t(
        vec3(0.0, 0.0, 0.0),
        vec3(0.0, 0.0, 0.0),
        empty_material(),
        0.0,
        vec2(0.0, 0.0),
        false
    );
}

void hit_record_set_front_face(inout hit_record_t record, 
                               const in ray_t ray,
                               const in vec3 outward_normal) {
    record.front_face = dot(ray.direction, outward_normal) < 0.0;
    record.normal = record.front_face ? outward_normal : -outward_normal;
}

bool hit_sphere(const in sphere_t sphere, 
                const in ray_t ray, 
                const in float t_min,
                const in float t_max,
                out hit_record_t record) {
    const vec3 oc = ray.origin - sphere.center;
    const float a = dot(ray.direction, ray.direction);
    const float half_b = dot(oc, ray.direction);
    const float c = dot(oc, oc) - sphere.radius * sphere.radius;
    const float discriminant = half_b * half_b - a * c;
    if (discriminant < 0.0) {
        return false;
    } else {
        float t = (-half_b - sqrt(discriminant)) / a;
        if (t < t_min || t > t_max) {
            t = (-half_b + sqrt(discriminant)) / a;
            if (t < t_min || t > t_max) {
                return false;
            }
        }
        record.t = t;
        record.point = ray_at(ray, record.t);
        const vec3 outward_normal = (record.point - sphere.center) / sphere.radius;
        hit_record_set_front_face(record, ray, outward_normal);
        record.material = sphere.material;
        const float phi = atan(outward_normal.x, outward_normal.z) + PI;
        const float theta = acos(outward_normal.y);
        record.albedo_uv.x = phi * (0.5 * ONE_OVER_PI);
        record.albedo_uv.y = theta * ONE_OVER_PI;
        return true;
    }
}

bool hit_triangle(const in triangle_t triangle,
                  const in ray_t ray,
                  const in float t_min,
                  const in float t_max,
                  out hit_record_t record) {
    const vec3 a = triangle_vertices[triangle.a].position.xyz;
    const vec3 b = triangle_vertices[triangle.b].position.xyz;
    const vec3 c = triangle_vertices[triangle.c].position.xyz;
    // check if the triangle is degenerate
    const vec3 edge1 = b - a;
    const vec3 edge2 = c - a;
    if (abs(length(cross(edge1, edge2))) < 1e-8) {
        return false;
    }
    // transform traingle vertices to ray space
    vec3 at = a - ray.origin;
    vec3 bt = b - ray.origin;
    vec3 ct = c - ray.origin;
    // permute direction and vertices
    const int kz = max_component_index(ray.direction);
    const int kx = kz + 1 == 3 ? 0 : kz + 1;
    const int ky = kx + 1 == 3 ? 0 : kx + 1;
    const vec3 d = vec3(ray.direction[kx], ray.direction[ky], ray.direction[kz]);
    at = vec3(at[kx], at[ky], at[kz]);
    bt = vec3(bt[kx], bt[ky], bt[kz]);
    ct = vec3(ct[kx], ct[ky], ct[kz]);
    // shear to +z
    const float sx = -d.x / d.z;
    const float sy = -d.y / d.z;
    const float sz =  1.0 / d.z;
    at.x += sx * at.z;
    at.y += sy * at.z;
    bt.x += sx * bt.z;
    bt.y += sy * bt.z;
    ct.x += sx * ct.z;
    ct.y += sy * ct.z;
    // compute scaled barycentric coord
    const float e0 = bt.x * ct.y - bt.y * ct.x;
    const float e1 = ct.x * at.y - ct.y * at.x;
    const float e2 = at.x * bt.y - at.y * bt.x;
    // perform determinant tests
    if ((e0 < 0 || e1 < 0 || e2 < 0) && (e0 > 0 || e1 > 0 || e2 > 0)) {
        return false;
    }
    const float det = e0 + e1 + e2;
    if (det == 0) {
        return false;
    }
    at.z *= sz;
    bt.z *= sz;
    ct.z *= sz;
    const float t_scaled = e0 * at.z + e1 * bt.z + e2 * ct.z;
    // test against t ranger
    if (det < 0 && (t_scaled >= t_min * det || t_scaled < t_max * det)) {
        return false;
    } else if (det > 0 && (t_scaled <= t_min * det || t_scaled > t_max * det)) {
        return false;
    }
    // baricentric coordinate
    const float inv_det = 1.0 / det;
    const float b0 = e0 * inv_det;
    const float b1 = e1 * inv_det;
    const float b2 = e2 * inv_det;
    const float t = t_scaled * inv_det;
    //record
    const vec3 a_normal = triangle_vertices[triangle.a].normal.xyz;
    const vec3 b_normal = triangle_vertices[triangle.b].normal.xyz;
    const vec3 c_normal = triangle_vertices[triangle.c].normal.xyz;
    const vec2 a_albedo_uv = triangle_vertices[triangle.a].albedo_uv;
    const vec2 b_albedo_uv = triangle_vertices[triangle.b].albedo_uv;
    const vec2 c_albedo_uv = triangle_vertices[triangle.c].albedo_uv;
    record.point = ray_at(ray, t);
    const vec3 outward_normal = b0 * a_normal + b1 * b_normal + b2 * c_normal;
    hit_record_set_front_face(record, ray, outward_normal);
    record.material = triangle_materials[triangle.material];
    record.t = t;
    record.albedo_uv = b0 * a_albedo_uv + b1 * b_albedo_uv + b2 * c_albedo_uv;
    return true;
}

vec3 gradient_background(const in vec3 top_color,
                         const in vec3 bottom_color,
                         const in ray_t ray) {
    const float a = 0.5 * (ray.direction.y + 1.0);
    return a * top_color + (1.0 - a) * bottom_color;
}

bool near_zero(const in vec3 vector) {
    const float mu = 1e-8;
    return abs(vector.x) < mu &&
           abs(vector.y) < mu &&
           abs(vector.z) < mu;
}

int max_component_index(const in vec3 vector) {
    const vec3 abs_vector = abs(vector);
    return abs_vector.x > abs_vector.y ?
               (abs_vector.x > abs_vector.z ? 0 : 2) :
               (abs_vector.y > abs_vector.z ? 1 : 2);
}

// vec3 reflect(in vec3 v, 
//             in vec3 n) {
//    return v - 2 * dot(v, n) * n;
// }

// vec3 refract(in vec3 uv, 
//             in vec3 n, 
//             in float etai_over_etat) {
//    const float cos_theta = min(dot(-uv, n), 1.0);
//    const vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);
//    const vec3 r_out_parallel = -sqrt(abs(1.0 - dot(r_out_perp, r_out_perp))) * n;
//    return r_out_perp + r_out_parallel;
// }

float reflectance(const in float cosine, 
                  const in float refraction_ratio) {
    // Use Schlick's approximation for reflectance.
    float r0 = (1 - refraction_ratio) / (1 + refraction_ratio);
    r0 = r0 * r0;
    return r0 + (1 - r0) * 
                (1 - cosine) *
                (1 - cosine) *
                (1 - cosine) *
                (1 - cosine) *
                (1 - cosine);
}

vec3 scatter(inout ray_t ray,
             const in hit_record_t hit_record) {
    switch (hit_record.material.type) {
        case MATERIAL_LAMBERTIAN:
            ray.origin = hit_record.point;
            ray.direction = normalize(hit_record.normal + 
                                      rand_vector_on_unit_sphere(hit_record.point.xy,
                                                                 hit_record.point.xz));
            if (near_zero(ray.direction)) {
                ray.direction = hit_record.normal;
            }
            return hit_record.material.albedo_texture >= 0 ? 
                texture(nonuniformEXT(textures[hit_record.material.albedo_texture]), 
                    hit_record.albedo_uv).rgb :
                hit_record.material.albedo.xyz;
        case MATERIAL_METAL:
            ray.origin = hit_record.point;
            const vec3 reflected = reflect(ray.direction, hit_record.normal) + 
                                   hit_record.material.fuzz *
                                       rand_vector_on_unit_sphere(hit_record.point.xy,
                                                                 hit_record.point.xz);
            ray.direction = reflected;
            return hit_record.material.albedo.xyz;
        case MATERIAL_DIELECTRIC:
            ray.origin = hit_record.point;
            const float refraction_ratio = hit_record.front_face ? 
                1.0 / hit_record.material.refraction_index :
                hit_record.material.refraction_index;
            const float cos_theta = min(dot(-ray.direction, hit_record.normal), 1.0);
            const float sin_theta = sqrt(1 - cos_theta * cos_theta);
            if (refraction_ratio * sin_theta > 1.0 ||
                reflectance(cos_theta, refraction_ratio) > rand_01(hit_record.point.xy)) {
                ray.direction = reflect(ray.direction, hit_record.normal);
            } else {
                ray.direction = refract(ray.direction, 
                                        hit_record.normal, 
                                        refraction_ratio);
            }
            return vec3(1.0, 1.0, 1.0);
    }
}

vec3 brute_force_ray_tracing(in ray_t ray) {
    vec3 destination_color = vec3(0.0, 0.0, 0.0);
    vec3 accumulated_attenuation = vec3(1.0, 1.0, 1.0);
    #pragma optionNV (unroll all)
    for (int iter = 0; iter < RAY_BOUNCE_MAX_COUNT; ++ iter) {
        const float t_min = 0.001;
        float t_max = 1.0 / 0.0;
        hit_record_t hit_record = empty_hit_record();
        bool hit_anything = false;
        #pragma optionNV (unroll all)
        for (uint sphere_idx = 0; sphere_idx < SPHERE_COUNT; ++ sphere_idx) {
            if (hit_sphere(spheres[sphere_idx], ray, t_min, t_max, hit_record)) {
                t_max = hit_record.t;
                hit_anything = true;
            }
        }
        for (uint triangle_idx = 0; triangle_idx < TRIANGLE_COUNT; ++ triangle_idx) {
            if (hit_triangle(triangles[triangle_idx], ray, t_min, t_max, hit_record)) {
                t_max = hit_record.t;
                hit_anything = true;
            }
        }
        if (hit_anything) {
            const vec3 attenuation = scatter(ray, hit_record);
            accumulated_attenuation = attenuation * accumulated_attenuation;
        } else {
            const vec3 sky_color = gradient_background(vec3(0.5, 0.7, 1.0), 
                                                       vec3(1.0, 1.0, 1.0),
                                                       ray);
            destination_color += accumulated_attenuation * sky_color;
            break;
        }
    }
    return destination_color;
}
