#version 450

#extension GL_EXT_scalar_block_layout: require

#define PI 3.1415926535

#define RAY_BOUNCE_MAX_COUNT 10
#define PIXEL_SAMPLE_COUNT 10

struct ray_t {
    vec3 origin;
    vec3 direction;
};

vec3 ray_at(const in ray_t ray,
            const in float t) {
    return ray.origin + t * ray.direction;
}

#define LAMBERTIAN_MATERIAL 0
#define METAL_MATERIAL 1

struct material_t {
    int type;
    vec3 albedo;
    float fuzz;
};

struct hit_record_t {
    vec3 point;
    // normal always points against ray direction
    vec3 normal;
    material_t material;
    float t;
    bool front_face;
};

hit_record_t empty_hit_record() {
    return hit_record_t(
        vec3(0.0, 0.0, 0.0),
        vec3(0.0, 0.0, 0.0),
        material_t(0, vec3(0.0, 0.0, 0.0), 0.0),
        0.0,
        false
    );
}

void hit_record_set_front_face(inout hit_record_t record, 
                               const in ray_t ray,
                               const in vec3 outward_normal) {
    record.front_face = dot(ray.direction, outward_normal) < 0.0;
    record.normal = record.front_face ? outward_normal : -outward_normal;
}

struct sphere_t {
    vec3 center;
    float radius;
    material_t material;
};

bool hit_sphere(const in sphere_t sphere, 
                const in ray_t ray, 
                const in float t_min,
                const in float t_max,
                out hit_record_t record) {
    const vec3 oc = ray.origin - sphere.center;
    const float a = dot(ray.direction, ray.direction);
    const float half_b = dot(oc, ray.direction);
    const float c = dot(oc, oc) - sphere.radius * sphere.radius;
    const float discriminant = half_b * half_b - a * c;
    if (discriminant < 0.0) {
        return false;
    } else {
        record.t = (-half_b - sqrt(discriminant)) / a;
        if (record.t < t_min || record.t > t_max) {
            return false;
        }
        record.point = ray_at(ray, record.t);
        const vec3 outward_normal = (record.point - sphere.center) / sphere.radius;
        hit_record_set_front_face(record, ray, outward_normal);
        record.material = sphere.material;
        return true;
    }
}

vec3 gradient_background(const in vec3 top_color,
                         const in vec3 bottom_color,
                         const in ray_t ray) {
    const float a = 0.5 * (ray.direction.y + 1.0);
    return a * top_color + (1.0 - a) * bottom_color;
}

float rand_01(const in vec2 co){
    return fract(sin(dot(co,vec2(12.9898,78.233))) * 43758.5453);
}

float rand_interval(const in vec2 co,
                    const in float min,
                    const in float max) {
    return min + (max - min) * rand_01(co);
}

vec3 rand_vector(const in vec3 v1,
                 const in vec3 v2) {
    return vec3(
        rand_01(v1.xy),
        rand_01(vec2(v1.z, v2.x)),
        rand_01(v2.yz)
    );
}

vec3 rand_vector_in_unit_sphere(const in vec3 v1,
                                const in vec3 v2) {
    const vec3 seed = rand_vector(v1, v2);
    const float theta = 2.0 * PI * seed.x;
    const float phi = 2.0 * PI * seed.y;
    return seed.z * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
}

vec3 rand_vector_on_unit_sphere(const in vec2 v1,
                                const in vec2 v2) {
    const float theta = rand_interval(v1, 0.0, 2 * PI);
    const float phi = rand_interval(v2, 0.0, 2 * PI);
    return vec3(cos(theta) * sin(phi), 
                sin(theta) * sin(phi), 
                cos(phi));
}

vec3 rand_vector_on_hemisphere(const in vec2 v1,
                               const in vec2 v2,
                               const in vec3 normal) {
    const vec3 random_unit_vector = rand_vector_on_unit_sphere(v1, v2);
    return dot(random_unit_vector, normal) <= 0.0 ? -random_unit_vector : 
                                                    random_unit_vector;
}

vec3 gamma_correct(const in vec3 value) {
    return sqrt(value);
}

bool near_zero(const in vec3 vector) {
    const float mu = 1e-8;
    return abs(vector.x) < mu &&
           abs(vector.y) < mu &&
           abs(vector.z) < mu;
}

vec3 scatter(inout ray_t ray,
             const in hit_record_t hit_record) {
    switch (hit_record.material.type) {
        case LAMBERTIAN_MATERIAL:
            ray.origin = hit_record.point;
            ray.direction = normalize(hit_record.normal + 
                                      rand_vector_on_unit_sphere(hit_record.point.xy,
                                                                 hit_record.point.xz));
            if (near_zero(ray.direction)) {
                ray.direction = hit_record.normal;
            }
            return hit_record.material.albedo.xyz;
        case METAL_MATERIAL:
            ray.origin = hit_record.point;
            const vec3 reflected = reflect(ray.direction, hit_record.normal) + 
                                   hit_record.material.fuzz *
                                       rand_vector_on_unit_sphere(hit_record.point.xy,
                                                                 hit_record.point.xz);
            ray.direction = normalize(reflected);
            return hit_record.material.albedo.xyz;
    }
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D img_output;

layout(constant_id = 0) const uint SPHERE_COUNT = 1;

layout(std430, binding = 0) uniform camera {
    vec3 pixel_delta_u;
    vec3 pixel_delta_v;
    vec3 upper_left_pixel;
    vec3 camera_position;
};

layout(std430, binding = 1) uniform geometries_sphere {
    sphere_t spheres[SPHERE_COUNT];
};

void main() {
    const ivec2 tex_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec3 pixel = upper_left_pixel + 
                 tex_coord.x * pixel_delta_u + 
                 (gl_NumWorkGroups.y - tex_coord.y) * pixel_delta_v;

    vec3 accumulated_color = vec3(0.0, 0.0, 0.0);
    for (int si = 0; si < PIXEL_SAMPLE_COUNT; ++ si) {
        const float sample_offset_x = -0.5 + rand_01(vec2(gl_GlobalInvocationID.x, float(si)));
        const float sample_offset_y = -0.5 + rand_01(vec2(gl_GlobalInvocationID.y, float(si)));
        const vec3 pixel_sample_offset = sample_offset_x * pixel_delta_u + 
                                         sample_offset_y * pixel_delta_v;
        const vec3 pixel_sample = pixel + pixel_sample_offset;
        ray_t ray = ray_t(camera_position, normalize(pixel_sample - camera_position));
        
        const float t_min = 0.001;
        float t_max = 1.0 / 0.0;
        vec3 accumulated_attenuation = vec3(1.0, 1.0, 1.0);
        for (int iter = 0; iter < RAY_BOUNCE_MAX_COUNT; ++ iter) {
            hit_record_t hit_record = empty_hit_record();
            bool hit_anything = false;
            for (int i = 0; i < SPHERE_COUNT; ++ i) {
                if (hit_sphere(spheres[i], ray, t_min, t_max, hit_record)) {
                    t_max = hit_record.t;
                    hit_anything = true;
                }
            }
            if (hit_anything) {
                const vec3 attenuation = scatter(ray, hit_record);
                accumulated_attenuation = attenuation * accumulated_attenuation;
            } else {
                const vec3 background_color = gradient_background(vec3(0.5, 0.7, 1.0), 
                                                                  vec3(1.0, 1.0, 1.0),
                                                                  ray);
                accumulated_color += accumulated_attenuation * background_color;
                break;
            }
        }
    }
    accumulated_color = accumulated_color * (1.0 / float(PIXEL_SAMPLE_COUNT));
    imageStore(img_output, 
               tex_coord, 
               vec4(gamma_correct(accumulated_color), 1.0));
}
