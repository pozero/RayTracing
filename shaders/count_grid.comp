#version 460

#extension GL_EXT_scalar_block_layout: require

#include "aabb.glsl"
#include "material.glsl"
#include "geometry.glsl"
#include "uniform_grid.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 1) uniform sphere_geometries {
    sphere_t spheres[SPHERE_COUNT];
};

layout(std430, binding = 2) uniform acceleration_structure {
    uniform_grid_t uniform_grid;
    aabb_t world_aabb;
};

layout(std430, binding = 0) buffer grid_start {
    uint grid_sphere_intersection_start[SPHERE_COUNT + 1];
};

void main() {
    const uint working_index = gl_GlobalInvocationID.x;
    const aabb_t aabb = spheres[working_index].aabb;
    const vec3 lowest_point = aabb_lowest_point(aabb);
    const vec3 highest_point = aabb_highest_point(aabb);
    const ivec3 lowest_grid = world2grid(uniform_grid, lowest_point);
    const ivec3 highest_grid = world2grid(uniform_grid, highest_point);
    const ivec3 grid_count = highest_grid - lowest_grid + ivec3(1, 1, 1);
    const uint count = grid_count.x * grid_count.y * grid_count.z;
    for (int i = working_index + 1; i <= SPHERE_COUNT; ++ i) {
        atomicAdd(grid_sphere_intersection_start[i], count);
    }
}
