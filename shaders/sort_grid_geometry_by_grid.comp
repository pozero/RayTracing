#version 460

// GPU side bitonic sort implementation from https://poniesandlight.co.uk/reflect/bitonic_merge_sort/

#extension GL_EXT_scalar_block_layout: require

// rounded up to power of 2
layout(constant_id = 0) const uint GRID_SPHERE_PAIR_ROUNDED_UP_COUNT = 1;

layout(constant_id = 1) const uint LOCAL_ELEMENTS_COUNT = 1;

#define LOCAL_BITONIC_MERGE_SORT 0
#define LOCAL_DISPERSE 1
#define BIG_FLIP 2
#define BIG_DISPERSE 3

layout(local_size_x_id = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 2) buffer intersection_pair_grid {
    uint intersection_grid_id[GRID_SPHERE_PAIR_ROUNDED_UP_COUNT];
};

layout(std430, binding = 3) buffer intersection_pair_geometry {
    uint intersection_sphere_id[GRID_SPHERE_PAIR_ROUNDED_UP_COUNT];
};

layout(std430, binding = 4) readonly buffer sorting_parameters {
    uint param_h;
    uint param_algorithm;
};

shared uint local_grid_id[LOCAL_ELEMENTS_COUNT * 2];
shared uint local_sphere_id[LOCAL_ELEMENTS_COUNT * 2];

bool is_bigger(const in uint left,
                const in uint right) {
    return left > right;
}

#define COMPARE is_bigger

void global_compare_and_swap(const in ivec2 idx) {
    if (COMPARE(intersection_grid_id[idx.x], intersection_grid_id[idx.y])) {
        uint tmp = intersection_grid_id[idx.x];
        intersection_grid_id[idx.x] = intersection_grid_id[idx.y];
        intersection_grid_id[idx.y] = tmp;

        tmp = intersection_sphere_id[idx.x];
        intersection_sphere_id[idx.x] = intersection_sphere_id[idx.y];
        intersection_sphere_id[idx.y] = tmp;
    }
}

void local_compare_and_swap(const in ivec2 idx) {
    if (COMPARE(local_grid_id[idx.x], local_grid_id[idx.y])) {
        uint tmp = local_grid_id[idx.x];
        local_grid_id[idx.x] = local_grid_id[idx.y];
        local_grid_id[idx.y] = tmp;

        tmp = local_sphere_id[idx.x];
        local_sphere_id[idx.x] = local_sphere_id[idx.y];
        local_sphere_id[idx.y] = tmp;
    }
}

ivec2 get_flip_coord(const in uint t, const in uint h) {
    const uint half_h = h / 2;
    const uint q = ((2 * t) / h) * h;
    const uint mod = t % half_h;
    const uint x = q + mod;
    const uint y = q + h - mod - 1;
    return ivec2(x, y);
}


ivec2 get_disperse_coord(const in uint t, const in uint h) {
    const uint half_h = h / 2;
    const uint q = ((2 * t) / h) * h;
    const uint mod = t % half_h;
    const uint x = q + mod;
    const uint y = q + mod + half_h;
    return ivec2(x, y);
}

void big_flip(const in uint h) {
    const uint t_prime = gl_GlobalInvocationID.x;
    global_compare_and_swap(get_flip_coord(t_prime, h));
}

void big_disperse(const in uint h) {
    const uint t_prime = gl_GlobalInvocationID.x;
    global_compare_and_swap(get_disperse_coord(t_prime, h));
}

void local_flip(const in uint h) {
    const uint t = gl_LocalInvocationID.x;
    barrier();
    local_compare_and_swap(get_flip_coord(t, h));
}

void local_disperse(const in uint h) {
    const uint t = gl_LocalInvocationID.x;
    for (uint hh = h; hh > 1; hh /=2) {
        barrier();
        local_compare_and_swap(get_disperse_coord(t, hh));
    }
}

void local_bms(const in uint h) {
    const uint t = gl_LocalInvocationID.x;
    for (uint hh = 2; hh <= h; hh *= 2) {
        local_flip(hh);
        local_disperse(hh / 2);
    }
}

void main() {
    const uint t = gl_LocalInvocationID.x;
    const uint global_offset = LOCAL_ELEMENTS_COUNT * 2 * gl_WorkGroupID.x;
    if (param_algorithm <= LOCAL_DISPERSE) {
        local_grid_id[t * 2] = intersection_grid_id[global_offset + t * 2];
        local_grid_id[t * 2 + 1] = intersection_grid_id[global_offset + t * 2 + 1];

        local_sphere_id[t * 2] = intersection_sphere_id[global_offset + t * 2];
        local_sphere_id[t * 2 + 1] = intersection_sphere_id[global_offset + t * 2 + 1];
    }

    switch(param_algorithm) {
        case LOCAL_BITONIC_MERGE_SORT:
            local_bms(param_h);
            break;
        case LOCAL_DISPERSE:
            local_disperse(param_h);
            break;
        case BIG_FLIP:
            big_flip(param_h);
            break;
        case BIG_DISPERSE:
            big_disperse(param_h);
            break;
    }

    if (param_algorithm <= LOCAL_DISPERSE) {
        barrier();
        intersection_grid_id[global_offset + t * 2] = local_grid_id[t * 2];
        intersection_grid_id[global_offset + t * 2 + 1] = local_grid_id[t * 2 + 1];

        intersection_sphere_id[global_offset + t * 2] = local_sphere_id[t * 2];
        intersection_sphere_id[global_offset + t * 2 + 1] = local_sphere_id[t * 2 + 1];
    }
}

