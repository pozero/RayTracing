#version 460

#extension GL_EXT_scalar_block_layout: require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D equirectangular_map;

layout(rgba32f, set = 0, binding = 1) uniform imageCube cubemap;

#define PI 3.1415926535

vec2 cartesian_to_spherical(vec3 v)
{
    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
    uv *= vec2(0.5 / PI, 1.0 / PI);
    uv += 0.5;
    return uv;
}

void main() {
    const ivec3 cubemap_tex = ivec3(gl_GlobalInvocationID.xyz);
    const vec2 normalized_face_tex = 
       vec2(2.0) * (vec2(cubemap_tex.st) / vec2(imageSize(cubemap))) - vec2(1.0);
    vec3 direction = vec3(0.0);
    switch (cubemap_tex.z) {
        // https://docs.vulkan.org/spec/latest/chapters/textures.html#_cube_map_face_selection
        // positive x, (1, -t, -s)
        case 0:
            direction = vec3(1.0, -normalized_face_tex.t, -normalized_face_tex.s);
            break;
        // negative x, (-1, -t, s)
        case 1:
            direction = vec3(-1.0, -normalized_face_tex.t, normalized_face_tex.s);
            break;
        // positive y, (s, 1, t)
        case 2:
            direction = vec3(normalized_face_tex.s, 1.0, normalized_face_tex.t);
            break;
        // negative y, (s, -1, -t)
        case 3:
            direction = vec3(normalized_face_tex.s, -1.0, -normalized_face_tex.t);
            break;
        // positive z, (s, -t, 1)
        case 4:
            direction = vec3(normalized_face_tex.s, -normalized_face_tex.t, 1.0);
            break;
        // negative z, (-s, -t, -1)
        case 5:
            direction = vec3(-normalized_face_tex.s, -normalized_face_tex.t, -1.0);
            break;
    }
    const vec2 equirectangular_map_tex = cartesian_to_spherical(normalize(direction));
    const vec3 color = texture(equirectangular_map, equirectangular_map_tex).rgb;
    imageStore(cubemap, cubemap_tex, vec4(color, 1.0));
}
