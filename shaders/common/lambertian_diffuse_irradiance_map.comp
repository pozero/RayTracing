#version 460

#extension GL_EXT_scalar_block_layout: require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform samplerCube environment_map;

layout(rgba32f, set = 0, binding = 1) uniform imageCube irradiance_map;

#define PI 3.1415926535

#include "../common/to_ldr.glsl"

void main() {
    const vec2 normalized_face_tex = 
       vec2(2.0) * (vec2(gl_GlobalInvocationID.st) / vec2(imageSize(irradiance_map))) - vec2(1.0);
    const vec3 directions[6] = vec3[6](
        // https://docs.vulkan.org/spec/latest/chapters/textures.html#_cube_map_face_selection
        // positive x, (1, -t, -s)
        vec3(1.0, -normalized_face_tex.t, -normalized_face_tex.s),
        // negative x, (-1, -t, s)
        vec3(-1.0, -normalized_face_tex.t, normalized_face_tex.s),
        // positive y, (s, 1, t)
        vec3(normalized_face_tex.s, 1.0, normalized_face_tex.t),
        // negative y, (s, -1, -t)
        vec3(normalized_face_tex.s, -1.0, -normalized_face_tex.t),
        // positive z, (s, -t, 1)
        vec3(normalized_face_tex.s, -normalized_face_tex.t, 1.0),
        // negative z, (-s, -t, -1)
        vec3(-normalized_face_tex.s, -normalized_face_tex.t, -1.0)
    );
    for (uint i = 0; i < 6; ++ i) {
        const ivec3 irradiance_map_tex = ivec3(gl_GlobalInvocationID.xy, i);
        const vec3 direction = directions[i];
        const vec3 up = normalize(direction);
        // would introduce subtle circle border around x axis, which should be fine
        const vec3 front = abs(up.x) < 0.8 ? normalize(cross(vec3(1.0, 0.0, 0.0), up)) :
            normalize(cross(up, vec3(0.0, 1.0, 0.0)));
        const vec3 left = normalize(cross(front, up));
        const float sample_delta = 0.5;
        vec3 irradiance = vec3(0.0);
        float sample_count = 0.0;
        for (float phi = 0.0; phi < 2.0 * PI; phi += sample_delta) {
            const float cos_phi = cos(phi);
            const float sin_phi = sin(phi);
            for (float theta = 0.0; theta < 0.5 * PI; theta += sample_delta) {
                const float cos_theta = cos(theta);
                const float sin_theta = sin(theta);
                const vec3 coord_in_normal_space = vec3(cos_phi * sin_theta, cos_theta, sin_phi * sin_theta);
                const vec3 sample_direction = coord_in_normal_space.x * front + 
                    coord_in_normal_space.y * up +
                    coord_in_normal_space.z * left;
                // transform the value to ldr space to avoid aliasing (filter the high frequence signal)
                const vec3 sampled_color = 
                    tone_mapping(texture(environment_map, sample_direction).rgb) * 
                    cos_theta * sin_theta;
                irradiance += sampled_color;
                sample_count += 1.0;
            }
        }
        irradiance = (PI * irradiance) / sample_count;
        imageStore(irradiance_map, irradiance_map_tex, vec4(irradiance, 1.0));
    }
}
