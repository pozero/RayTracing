#version 460

#extension GL_EXT_scalar_block_layout: require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rg32f, set = 0, binding = 0) uniform image2D brdf_lut;

#define PI 3.1415926535

#include "../common/low_discrepancy_sequence.glsl"

float ibl_lighting_geometry_schlick_ggx(const in float dot_product,
                                        const in float roughness) {
    const float k = (roughness * roughness) / 2.0;
    const float numerator = dot_product;
    const float denominator = dot_product * (1.0 - k) + k;
    return numerator / denominator;
}

float ibl_lighting_geometry_smith(const in vec3 normal,
                                  const in vec3 view,
                                  const in vec3 light,
                                  const in float roughness) {
    const float n_dot_v = max(dot(normal, view), 0.0);
    const float n_dot_l = max(dot(normal, light), 0.0);
    const float geometry_masking = ibl_lighting_geometry_schlick_ggx(n_dot_v, roughness);
    const float geometry_shadowing = ibl_lighting_geometry_schlick_ggx(n_dot_l, roughness);
    return geometry_masking * geometry_shadowing;
}

vec3 distribution_ggx_importance_sampling(const in vec2 xi, 
                                          const in vec3 normal,
                                          const in float roughness) {
    const float a = roughness * roughness;
    const float phi = 2.0 * PI * xi.x;
    // derivation see https://agraphicsguynotes.com/posts/sample_microfacet_brdf/
    const float cos_theta = sqrt((1.0 - xi.y) / (xi.y * (a * a - 1.0) + 1.0));
    const float sin_theta = sqrt(1.0 - cos_theta * cos_theta);
    // normal vector being z axis
    const vec3 coord_in_normal_space = vec3(cos(phi) * sin_theta, sin(phi) * sin_theta,
        cos_theta);
    return normalize(coord_in_normal_space);
}

vec2 integrate_brdf(const in float n_dot_v,
                    const in float roughness) {
    const vec3 normal = vec3(0.0, 0.0, 1.0);
    const vec3 view = vec3(sqrt(1.0 - n_dot_v * n_dot_v), 0.0, n_dot_v);
    const uint sample_count = 1024;
    float f0_scale = 0.0;
    float f0_bias = 0.0;
    for (uint i = 0; i < sample_count; ++ i) {
        const vec2 xi = hammersley(i, sample_count);
        const vec3 half_vec = distribution_ggx_importance_sampling(xi, normal, roughness);
        const vec3 light_vec = normalize(2.0 * dot(view, half_vec) * half_vec - view);
        const float n_dot_l = max(light_vec.z, 0.0);
        const float n_dot_h = max(half_vec.z, 0.0);
        const float v_dot_h = max(dot(view, half_vec), 0.0);
        if (n_dot_l > 0.0) {
            // Incident light = SampleColor * NoL
            // Microfacet specular = D*G*F / (4*NoL*NoV)
            // pdf = D * NoH / (4 * VoH)
            const float geometry = ibl_lighting_geometry_smith(normal, view, light_vec, roughness);
            const float alpha = pow(1.0 - v_dot_h, 5.0);
            const float brdf_over_pdf = (geometry * v_dot_h) / (n_dot_h * n_dot_v + 0.0001);
            f0_scale += (1 - alpha) * brdf_over_pdf;
            f0_bias += alpha * brdf_over_pdf;
        }
    }
    return vec2(f0_scale, f0_bias) / sample_count;
}

void main() {
    const ivec2 lut_tex = ivec2(gl_GlobalInvocationID.st);
    const vec2 lut_tex_coord = lut_tex / vec2(imageSize(brdf_lut));
    const vec2 value = integrate_brdf(lut_tex_coord.s, lut_tex_coord.t);
    imageStore(brdf_lut, lut_tex, vec4(value, 0.0, 1.0));
}
