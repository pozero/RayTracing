#version 460

#extension GL_EXT_scalar_block_layout: require

layout(constant_id = 0) const uint SPHERE_COUNT = 1;

layout(constant_id = 1) const uint GRID_ALONG_X_AXIS = 1;

layout(constant_id = 2) const uint GRID_ALONG_Y_AXIS = 1;

layout(constant_id = 3) const uint GRID_ALONG_Z_AXIS = 1;

// rounded up to power of 2
layout(constant_id = 4) const uint GRID_SPHERE_PAIR_ROUNDED_UP_COUNT = 1;

#include "aabb.glsl"
#include "material.glsl"
#include "geometry.glsl"
#include "uniform_grid.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer intersection_start {
    uint grid_sphere_intersection_start[SPHERE_COUNT + 1];
};

layout(std430, binding = 1) readonly buffer sphere_grid_occupation {
    ivec3 grid_occupation_pair[SPHERE_COUNT * 2];
};

layout(std430, binding = 2) writeonly buffer intersection_pair {
    uint intersection_grid_sphere_id[GRID_SPHERE_PAIR_ROUNDED_UP_COUNT * 2];
};

void main() {
    const uint working_index = gl_GlobalInvocationID.x;
    const ivec3 lowest_grid = grid_occupation_pair[2 * working_index];
    const ivec3 highest_grid = grid_occupation_pair[2 * working_index + 1];
    uint pair_index = grid_sphere_intersection_start[working_index];
    for (int z = lowest_grid.z; z <= highest_grid.z; ++ z) {
        for (int y = lowest_grid.y; y <= highest_grid.y; ++ y) {
            for (int x = lowest_grid.x; x <= highest_grid.x; ++ x) {
                intersection_grid_sphere_id[2 * pair_index] = flatten_grid_coord(ivec3(x, y, z));
                intersection_grid_sphere_id[2 * pair_index + 1] = working_index;
                ++ pair_index;
            }
        }
    }
}
