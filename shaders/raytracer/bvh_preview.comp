#version 460

#extension GL_EXT_scalar_block_layout: require

#include "../common/utils.glsl"
#include "../common/geometry.glsl"
#include "state.glsl"
#include "aabb.glsl"
#include "bvh.glsl"
#include "ray.glsl"
#include "camera.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) readonly buffer TLAS {
    bvh_node_t tlas[];
};

layout(std430, set = 0, binding = 1) readonly buffer BLAS {
    bvh_node_t blas[];
};

layout(std430, set = 1, binding = 0) readonly buffer MESH {
    mesh_t meshes[];
};

layout(std430, set = 1, binding = 1) readonly buffer INVERSE_TRANSFORM {
    mat4 inverse_transforms[];
};

layout(std430, set = 1, binding = 2) readonly buffer INSTANCE {
    instance_t instances[];
};

layout(rgba32f, set = 2, binding = 0) uniform image2D out_img;

layout(push_constant, std430) uniform PUSH_CONSTANT {
    float packed_camera[12];
};

vec3 bvh_traversal(const in ray_t ray);

void main() {
    const camera_t camera = unpack_camera(packed_camera);
    const ivec2 tex_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec3 pixel = camera.upper_left_pixel + 
        tex_coord.x * camera.pixel_delta_u + 
        tex_coord.y * camera.pixel_delta_v;
    ray_t ray = ray_t(camera.position, normalize(pixel - camera.position));
    const vec3 color = bvh_traversal(ray);
    imageStore(out_img, tex_coord, vec4(color, 1.0));
}

vec3 bvh_traversal(const in ray_t ray) {
    const vec3 inv_dir = vec3(1.0) / ray.direction;
    const ivec3 neg_dir = ivec3(ray.direction.x < 0.0,
                                ray.direction.y < 0.0,
                                ray.direction.z < 0.0);
    uint tlas_current_node = 0;
    stack_t nodes_to_visit;
    nodes_to_visit.top = 0;
    vector_t instances_to_visit;
    instances_to_visit.size = 0;
    uint visit_count = 0;
    while (true) {
        const bvh_node_t node = tlas[tlas_current_node];
        ++ visit_count;
        if (hit_aabb(node.aabb, ray, inv_dir, neg_dir, 0.0, INFINITY)) {
            if (node.obj_count > 0) {
                for (uint i = node.first_obj; i < node.first_obj + node.obj_count; ++ i) {
                    push_vector(instances_to_visit, i);
                }
                if (!pop_stack(nodes_to_visit, tlas_current_node)) {
                    break;
                }
            } else {
                const bool neg = neg_dir[node.split_axis] != 0;
                const uint cur_node = neg ? node.right : tlas_current_node + 1;
                const uint next_node = neg ? tlas_current_node + 1 : node.right;
                tlas_current_node = cur_node;
                push_stack(nodes_to_visit, next_node);
            }
        } else {
            if (!pop_stack(nodes_to_visit, tlas_current_node)) {
                break;
            }
        }
    }
    const float t_min = 0.0;
    float t_max = INFINITY;
    for (uint i = 0; i < instances_to_visit.size; ++ i) {
        const instance_t instance = instances[instances_to_visit.data[i]];
        const mesh_t mesh = meshes[instance.mesh];
        const mat4 inverse_transform = instance.transform >= 0 ? inverse_transforms[instance.transform] :
            mat4(1.0);
        const ray_t transformed_ray = ray_t(vec3(inverse_transform * vec4(ray.origin, 1.0)),
                                            vec3(inverse_transform * vec4(ray.direction, 0.0)));
        const vec3 t_inv_dir = vec3(1.0) / transformed_ray.direction;
        const ivec3 t_neg_dir = ivec3(transformed_ray.direction.x < 0.0,
                                      transformed_ray.direction.y < 0.0,
                                      transformed_ray.direction.z < 0.0);
        uint blas_current_node = mesh.bvh_start;
        clear_stack(nodes_to_visit);
        while (true) {
            ++ visit_count;
            const bvh_node_t node = blas[blas_current_node];
            if (hit_aabb(node.aabb, transformed_ray, t_inv_dir, t_neg_dir, t_min, t_max)) {
                if (node.obj_count > 0) {
                    if (!pop_stack(nodes_to_visit, blas_current_node)) {
                        break;
                    }
                } else {
                    const bool neg = t_neg_dir[node.split_axis] != 0;
                    const uint cur_node = neg ? node.right : blas_current_node + 1;
                    const uint next_node = neg ? blas_current_node + 1 : node.right;
                    blas_current_node = cur_node;
                    push_stack(nodes_to_visit, next_node);
                }
            } else {
                if (!pop_stack(nodes_to_visit, blas_current_node)) {
                    break;
                }
            }
        }
    }
    const float node_density = visit_count / 30.0f;
    const vec3 color = vec3(node_density, 0.0, 1.0 - node_density);
    return color;
}
