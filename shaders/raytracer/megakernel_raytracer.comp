#version 460

#extension GL_EXT_scalar_block_layout: require
#extension GL_EXT_nonuniform_qualifier: require

layout(push_constant, std430) uniform PUSH_CONSTANT {
    float packed_camera[12];
    uint random_seed;
    uint preview;
    uint max_depth;
    uint light_count;
    int sky_light;
};

uint seed = random_seed;

#include "../common/utils.glsl"
#include "../common/geometry.glsl"
#include "../common/material.glsl"
#include "../common/light.glsl"
#include "../common/random.glsl"
#include "state.glsl"
#include "aabb.glsl"
#include "bvh.glsl"
#include "ray.glsl"
#include "camera.glsl"
#include "sampling.glsl"
#include "disney.glsl"

layout(std430, set = 0, binding = 0) readonly buffer TLAS {
    bvh_node_t tlas[];
};

layout(std430, set = 0, binding = 1) readonly buffer BLAS {
    bvh_node_t blas[];
};

layout(std430, set = 1, binding = 0) readonly buffer MESH {
    mesh_t meshes[];
};

layout(std430, set = 1, binding = 1) readonly buffer TRANSFORM {
    mat4 transforms[];
};

layout(std430, set = 1, binding = 2) readonly buffer INVERSE_TRANSFORM {
    mat4 inverse_transforms[];
};

layout(std430, set = 1, binding = 3) readonly buffer INSTANCE {
    instance_t instances[];
};

layout(std430, set = 1, binding = 4) readonly buffer TRIANGLES {
    vec4 packed_triangles[];
};

layout(std430, set = 2, binding = 0) readonly buffer MATERIAL {
    material_t materials[];
};

layout(std430, set = 2, binding = 1) readonly buffer MEDIUM {
    medium_t mediums[];
};

layout(std430, set = 2, binding = 2) readonly buffer LIGHT {
    light_t lights[];
};

layout(rgba32f, set = 3, binding = 0) uniform image2D out_img[2];

layout(set = 3, binding = 1) uniform sampler2D textures[];

triangle_t unpack_triangle(const in uint idx);

void get_surface_info(inout state_t state,
                      out surface_info_t surface_info);

bool closest_hit(const in ray_t ray,
                 inout state_t state);

bool any_hit(const in ray_t ray,
             const in float t_max);

vec3 ray_trace(in ray_t ray);

void main() {
    const camera_t camera = unpack_camera(packed_camera);
    const ivec2 tex_coord = ivec2(gl_GlobalInvocationID.xy);
    const uint flat_tex_coord = imageSize(out_img[preview]).x * tex_coord.y + tex_coord.x;
    random_seed_hash_combine(flat_tex_coord);
    const vec3 pixel = camera.upper_left_pixel + 
        tex_coord.x * camera.pixel_delta_u + 
        tex_coord.y * camera.pixel_delta_v;
    const float sample_offset_x = -0.5 + rand_01();
    const float sample_offset_y = -0.5 + rand_01();
    const vec3 pixel_sample_offset = sample_offset_x * camera.pixel_delta_u + 
                                     sample_offset_y * camera.pixel_delta_v;
    const vec3 pixel_sample = pixel + pixel_sample_offset;
    const ray_t ray = ray_t(camera.position, normalize(pixel_sample - camera.position));
    const vec3 color = ray_trace(ray);
    if (preview == 1) {
        imageStore(out_img[1], tex_coord, vec4(color, 1.0));
    } else {
        const vec3 accumulated = imageLoad(out_img[0], tex_coord).xyz;
        imageStore(out_img[0], tex_coord, vec4(accumulated + color, 1.0));
    }
}

triangle_t unpack_triangle(const in uint idx) {
    const vertex_t a = unpack_vertex(packed_triangles[idx * 6 + 0],
                                     packed_triangles[idx * 6 + 1]);
    const vertex_t b = unpack_vertex(packed_triangles[idx * 6 + 2],
                                     packed_triangles[idx * 6 + 3]);
    const vertex_t c = unpack_vertex(packed_triangles[idx * 6 + 4],
                                     packed_triangles[idx * 6 + 5]);
    return triangle_t(a, b, c);
}

void get_surface_info(inout state_t state,
                      out surface_info_t surface_info) {
    surface_info = empty_surface_info();
    if (state.inst_light >= 0) {
        const light_t light = lights[state.inst_light];
        if (state.front_face || light.type == LIGHT_AREA_DOUBLE_SIDED) {
            surface_info.emission = light.intensity;
            if (light.emission_tex >= 0) {
                surface_info.emission *= texture(textures[light.emission_tex], state.hit_uv).rgb;
            }
        } else {
            surface_info.emission = vec3(0.0);
        }
    } else if (state.inst_material >= 0) {
        const material_t material = materials[state.inst_material];
        surface_info.albedo = material.albedo;
        surface_info.emission = material.emission;
        surface_info.metallic = material.metallic;
        surface_info.spec_trans = material.spec_trans;
        surface_info.eta = state.front_face ? 1.0 / material.ior : material.ior;
        surface_info.ior = material.ior;
        surface_info.subsurface = material.subsurface;
        surface_info.roughness = material.roughness;
        surface_info.specular_tint = material.specular_tint;
        surface_info.anisotropic = material.anisotropic;
        surface_info.sheen = material.sheen;
        surface_info.sheen_tint = material.sheen_tint;
        surface_info.clearcoat = material.clearcoat;
        surface_info.clearcoat_gloss = material.clearcoat_gloss;
        if (material.albedo_tex >= 0) {
            surface_info.albedo *= texture(textures[material.albedo_tex], state.hit_uv).rgb;
        }
        if (material.emission_tex >= 0) {
            surface_info.emission *= texture(textures[material.emission_tex], state.hit_uv).rgb;
        }
        if (material.normal_tex >= 0) {
            const vec3 normal_texel = normalize(texture(textures[material.normal_tex], state.hit_uv).rgb * 2.0 - 
                                                vec3(1.0));
            state.hit_normal = normalize(normal_texel.x * state.hit_tangent +
                                         normal_texel.y * state.hit_bitangent +
                                         normal_texel.z * state.hit_normal);
        }
        if (material.metallic_roughness_tex >= 0) {
            const vec2 mr_texel = texture(textures[material.metallic_roughness_tex], state.hit_uv).bg;
            surface_info.metallic = mr_texel.x;
            surface_info.roughness = max(mr_texel.y * mr_texel.y, 0.001);
        }
        const float aspect = sqrt(1.0 - material.anisotropic * 0.9);
        surface_info.ax = max(0.001, material.roughness / aspect);
        surface_info.ay = max(0.001, material.roughness * aspect);
    }
}

bool closest_hit(const in ray_t ray,
                 inout state_t state) {
    const float t_min = 0.0;
    float t_max = INFINITY;
    stack_t nodes_to_visit;
    nodes_to_visit.top = 0;
    vector_t instances_to_visit;
    instances_to_visit.size = 0;
    {
        const vec3 inv_dir = vec3(1.0) / ray.direction;
        const ivec3 neg_dir = ivec3(ray.direction.x < 0.0,
                                    ray.direction.y < 0.0,
                                    ray.direction.z < 0.0);
        uint tlas_current_node = 0;
        while (true) {
            const bvh_node_t node = tlas[tlas_current_node];
            if (hit_aabb(node.aabb, ray, inv_dir, neg_dir, t_min, t_max)) {
                if (node.obj_count > 0) {
                    for (uint i = node.first_obj; i < node.first_obj + node.obj_count; ++ i) {
                        push_vector(instances_to_visit, i);
                    }
                    if (!pop_stack(nodes_to_visit, tlas_current_node)) {
                        break;
                    }
                } else {
                    const bool neg = neg_dir[node.split_axis] != 0;
                    const uint cur_node = neg ? node.right : tlas_current_node + 1;
                    const uint next_node = neg ? tlas_current_node + 1 : node.right;
                    tlas_current_node = cur_node;
                    push_stack(nodes_to_visit, next_node);
                }
            } else {
                if (!pop_stack(nodes_to_visit, tlas_current_node)) {
                    break;
                }
            }
        }
    }
    uint closest_instance;
    uint closest_triangle;
    hit_record_t closest_hit_record;
    for (uint i = 0; i < instances_to_visit.size; ++ i) {
        const instance_t instance = instances[instances_to_visit.data[i]];
        const mesh_t mesh = meshes[instance.mesh];
        const mat4 inverse_transform = instance.transform >= 0 ? inverse_transforms[instance.transform] :
            mat4(1.0);
        const ray_t transformed_ray = ray_t(vec3(inverse_transform * vec4(ray.origin, 1.0)),
                                            vec3(inverse_transform * vec4(ray.direction, 0.0)));
        const vec3 inv_dir = vec3(1.0) / transformed_ray.direction;
        const ivec3 neg_dir = ivec3(transformed_ray.direction.x < 0.0,
                                    transformed_ray.direction.y < 0.0,
                                    transformed_ray.direction.z < 0.0);
        uint blas_current_node = mesh.bvh_start;
        clear_stack(nodes_to_visit);
        while (true) {
            const bvh_node_t node = blas[blas_current_node];
            if (hit_aabb(node.aabb, transformed_ray, inv_dir, neg_dir, t_min, t_max)) {
                if (node.obj_count > 0) {
                    for (uint t = node.first_obj; t < node.first_obj + node.obj_count; ++ t) {
                        const triangle_t triangle = unpack_triangle(t);
                        const hit_record_t hit_rec = hit_triangle(triangle, transformed_ray, t_min, t_max);
                        if (hit_rec.hit) {
                            t_max = hit_rec.t;
                            closest_instance = instances_to_visit.data[i];
                            closest_triangle = t;
                            closest_hit_record = hit_rec;
                        }
                    }
                    if (!pop_stack(nodes_to_visit, blas_current_node)) {
                        break;
                    }
                } else {
                    const bool neg = neg_dir[node.split_axis] != 0;
                    const uint cur_node = neg ? node.right : blas_current_node + 1;
                    const uint next_node = neg ? blas_current_node + 1 : node.right;
                    blas_current_node = cur_node;
                    push_stack(nodes_to_visit, next_node);
                }
            } else {
                if (!pop_stack(nodes_to_visit, blas_current_node)) {
                    break;
                }
            }
        }
    }
    if (t_max == INFINITY) {
        return false;
    }
    const instance_t instance = instances[closest_instance];
    const triangle_t triangle = unpack_triangle(closest_triangle);
    const vec3 a = triangle.a.position;
    const vec3 b = triangle.b.position;
    const vec3 c = triangle.c.position;
    const vec3 a_normal = triangle.a.normal;
    const vec3 b_normal = triangle.b.normal;
    const vec3 c_normal = triangle.c.normal;
    const vec2 a_uv = triangle.a.tex_coord;
    const vec2 b_uv = triangle.b.tex_coord;
    const vec2 c_uv = triangle.c.tex_coord;
    state.hit_position = ray_at(ray, closest_hit_record.t);
    // normal coordinate in model space
    const vec3 outward_normal = closest_hit_record.b0 * a_normal + 
        closest_hit_record.b1 * b_normal + 
        closest_hit_record.b2 * c_normal;
    state.front_face = dot(ray.direction, outward_normal) < 0.0;
    state.hit_normal = state.front_face ? outward_normal : -outward_normal;
    const vec3 delta_pos1 = b - a;
    const vec3 delta_pos2 = c - a;
    const vec2 delta_uv1 = b_uv - a_uv;
    const vec2 delta_uv2 = c_uv - a_uv;
    const float delta_uv_inv_dev = 1.0 / (delta_uv1.x * delta_uv2.y - delta_uv2.x * delta_uv1.y);
    state.hit_tangent = delta_uv_inv_dev * (delta_uv2.y * delta_pos1 - delta_uv1.y * delta_pos2);
    state.hit_bitangent = delta_uv_inv_dev * (-delta_uv2.x * delta_pos1 + delta_uv1.x * delta_pos2);
    // transform to world space
    if (instance.transform >= 0) {
        const mat4 transform = transforms[instance.transform];
        state.hit_normal = normalize(transpose(inverse(mat3(transform))) * state.hit_normal);
        state.hit_tangent = normalize(mat3(transform) * state.hit_tangent);
        state.hit_bitangent = normalize(mat3(transform) * state.hit_bitangent);
    }
    state.hit_uv = closest_hit_record.b0 * a_uv + 
        closest_hit_record.b1 * b_uv + 
        closest_hit_record.b2 * c_uv;
    state.hit_t = closest_hit_record.t;
    state.inst_material = instance.material;
    state.inst_medium = instance.medium;
    state.inst_light = instance.light;
    return true;
}

bool any_hit(const in ray_t ray,
             const in float t_max) {
    const float t_min = 0.0;
    stack_t nodes_to_visit;
    nodes_to_visit.top = 0;
    vector_t instances_to_visit;
    instances_to_visit.size = 0;
    {
        const vec3 inv_dir = vec3(1.0) / ray.direction;
        const ivec3 neg_dir = ivec3(ray.direction.x < 0.0,
                                    ray.direction.y < 0.0,
                                    ray.direction.z < 0.0);
        uint tlas_current_node = 0;
        while (true) {
            const bvh_node_t node = tlas[tlas_current_node];
            if (hit_aabb(node.aabb, ray, inv_dir, neg_dir, t_min, t_max)) {
                if (node.obj_count > 0) {
                    for (uint i = node.first_obj; i < node.first_obj + node.obj_count; ++ i) {
                        push_vector(instances_to_visit, i);
                    }
                    if (!pop_stack(nodes_to_visit, tlas_current_node)) {
                        break;
                    }
                } else {
                    const bool neg = neg_dir[node.split_axis] != 0;
                    const uint cur_node = neg ? node.right : tlas_current_node + 1;
                    const uint next_node = neg ? tlas_current_node + 1 : node.right;
                    tlas_current_node = cur_node;
                    push_stack(nodes_to_visit, next_node);
                }
            } else {
                if (!pop_stack(nodes_to_visit, tlas_current_node)) {
                    break;
                }
            }
        }
    }
    for (uint i = 0; i < instances_to_visit.size; ++ i) {
        const instance_t instance = instances[instances_to_visit.data[i]];
        const mesh_t mesh = meshes[instance.mesh];
        const mat4 inverse_transform = instance.transform >= 0 ? inverse_transforms[instance.transform] :
            mat4(1.0);
        const ray_t transformed_ray = ray_t(vec3(inverse_transform * vec4(ray.origin, 1.0)),
                                            vec3(inverse_transform * vec4(ray.direction, 0.0)));
        const vec3 inv_dir = vec3(1.0) / transformed_ray.direction;
        const ivec3 neg_dir = ivec3(transformed_ray.direction.x < 0.0,
                                    transformed_ray.direction.y < 0.0,
                                    transformed_ray.direction.z < 0.0);
        uint blas_current_node = mesh.bvh_start;
        clear_stack(nodes_to_visit);
        while (true) {
            const bvh_node_t node = blas[blas_current_node];
            if (hit_aabb(node.aabb, transformed_ray, inv_dir, neg_dir, t_min, t_max)) {
                if (node.obj_count > 0) {
                    for (uint t = node.first_obj; t < node.first_obj + node.obj_count; ++ t) {
                        const triangle_t triangle = unpack_triangle(t);
                        if (hit_triangle_quick(triangle, transformed_ray, t_min, t_max)) {
                            return true;
                        }
                    }
                    if (!pop_stack(nodes_to_visit, blas_current_node)) {
                        break;
                    }
                } else {
                    const bool neg = neg_dir[node.split_axis] != 0;
                    const uint cur_node = neg ? node.right : blas_current_node + 1;
                    const uint next_node = neg ? blas_current_node + 1 : node.right;
                    blas_current_node = cur_node;
                    push_stack(nodes_to_visit, next_node);
                }
            } else {
                if (!pop_stack(nodes_to_visit, blas_current_node)) {
                    break;
                }
            }
        }
    }
    return false;
}

bool sample_light(const in ray_t ray,
                  const in vec3 position,
                  out light_sample_t light_sample) {
    light_sample = empty_light_sample();
    const float light_pdf = 1.0 / light_count;
    const light_t light = lights[rand_uint(0, light_count - 1)];
    const float infinity_light_t_max = INFINITY - EPSILON;
    light_sample.type = light.type;
    if (light.type == LIGHT_SKY) {
    } else if (light.type == LIGHT_DISTANT) {
    } else if (light.type == LIGHT_AREA_SINGLE_SIDED ||
               light.type == LIGHT_AREA_DOUBLE_SIDED) {
        const mesh_t mesh = meshes[light.mesh];
        const uint triangle_i = mesh.triangle_offset +
            rand_uint(0, mesh.triangle_count - 1);
        const mat4 transform = light.transform >= 0 ? 
            transforms[light.transform] :
            mat4(1.0);
        const mat3 inverse_transform = light.transform >= 0 ?
            inverse(mat3(transform)) :
            mat3(1.0);
        const triangle_t triangle = unpack_triangle(triangle_i);
        const vec3 tri_coord = uniform_sampling_triangle();
        const vec3 light_sample_pos = vec3(transform * 
           vec4(tri_coord.x * triangle.a.position +
                tri_coord.y * triangle.b.position +
                tri_coord.z * triangle.c.position, 1.0));
        const vec3 light_sample_nor = transpose(inverse_transform) *
           (tri_coord.x * triangle.a.normal +
            tri_coord.y * triangle.b.normal +
            tri_coord.z * triangle.c.normal);
        const vec3 light_to_frag = light_sample_pos - position;
        if (light.type != LIGHT_AREA_DOUBLE_SIDED &&
            dot(light_to_frag, light_sample_nor) > 0.0) {
            return false;
        }
        const float light_frag_dist = length(light_to_frag);
        const float light_frag_dist2 = light_frag_dist * light_frag_dist;
        const vec3 light_frag_direction = light_to_frag / light_frag_dist;
        const ray_t shadow_ray = ray_t(position, light_frag_direction);
        if (any_hit(shadow_ray, light_frag_dist - EPSILON)) {
            return false;
        }
        vec3 intensity = light.intensity;
        if (light.emission_tex >= 0) {
            const vec2 uv = tri_coord.x * triangle.a.tex_coord +
                tri_coord.y * triangle.b.tex_coord +
                tri_coord.z * triangle.c.tex_coord;
            intensity *= texture(textures[light.emission_tex], uv).rgb;
        }
        const float pdf_on_light = 1.0 / light.direction.x;
        light_sample.intensity = intensity;
        light_sample.pdf = light_pdf * pdf_on_light *
            (light_frag_dist2 / abs(dot(light_sample_nor, light_frag_direction)));
        light_sample.wi = shadow_ray.direction;
        return true;
    }
    return false;
}

vec3 ray_trace(in ray_t ray) {
    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    state_t state;
    surface_info_t surface_info;
    light_sample_t light_sample;
    vec4 bsdf_pdf;
    for (uint depth = 0; ; ++ depth) {
        const bool hit_any = closest_hit(ray, state);
        if (!hit_any) {
            break;
        }
        get_surface_info(state, surface_info);
        radiance += surface_info.emission * throughput;
        if (state.inst_light >= 0) {
            break;
        }
        if (depth == max_depth) {
            break;
        }
        const vec3 front_face_normal = get_front_face_normal(state);
        const vec3 shadow_ray_origin = state.hit_position + EPSILON * front_face_normal;
        if (sample_light(ray, shadow_ray_origin, light_sample)) {
            const bool is_delta = light_sample.type == LIGHT_DISTANT;
            bsdf_pdf = eval_disney(state, surface_info, ray.direction, light_sample.wi);
            if (bsdf_pdf.w > 0.0) {
                const float mis = is_delta ? 1.0 : power_heuristic(light_sample.pdf, bsdf_pdf.w);
                radiance += (mis * bsdf_pdf.xyz * light_sample.intensity / light_sample.pdf) * throughput;
            }
        }
        const vec3 next_direction = sample_disney(state, surface_info, ray.direction);
        bsdf_pdf = eval_disney(state, surface_info, ray.direction, next_direction);
        if (bsdf_pdf.w > 0.0) {
            throughput *= bsdf_pdf.xyz / bsdf_pdf.w;
        } else {
            break;
        }
        ray.direction = next_direction;
        ray.origin = state.hit_position + next_direction * EPSILON;
    }
    return radiance;
}
